1. [Array (1678)](https://leetcode.com/tag/array/)
2. [String (705)](https://leetcode.com/tag/string/)
3. [Hash Table (613)](https://leetcode.com/tag/hash-table/)
    - Wikipedia: [Hash table](https://en.wikipedia.org/wiki/Hash_table)
4. [Dynamic Programming (510)](https://leetcode.com/tag/dynamic-programming/)
    - Wikipedia: [Dynamic programming](https://en.wikipedia.org/wiki/Dynamic_programming#Computer_science)
    - Wikipedia: [Bottom–up and top–down design](https://en.wikipedia.org/wiki/Bottom%E2%80%93up_and_top%E2%80%93down_design)
5. [Math (502)](https://leetcode.com/tag/math/)
    - Wikipedia: [Mathematics](https://en.wikipedia.org/wiki/Mathematics)
6. [Sorting (406)](https://leetcode.com/tag/sorting/)
7. [Greedy (365)](https://leetcode.com/tag/greedy/)
    - Wikipedia: [Greedy algorithm](https://en.wikipedia.org/wiki/Greedy_algorithm)
8. [Depth-First Search (288)](https://leetcode.com/tag/depth-first-search/)
    - Wikipedia: [Depth-first search](https://en.wikipedia.org/wiki/Depth-first_search)
9. [Database (272)](https://leetcode.com/tag/database/)
10. [Binary Search (269)](https://leetcode.com/tag/binary-search/)
    - Wikipedia: [Binary search](https://en.wikipedia.org/wiki/Binary_search)
11. [Tree (229)](https://leetcode.com/tag/tree/)
    - Wikipedia: [Tree (data structure)](https://en.wikipedia.org/wiki/Tree_(data_structure))
12. [Breadth-First Search (228)](https://leetcode.com/tag/breadth-first-search/)
    - Wikipedia: [Breadth-first search](https://en.wikipedia.org/wiki/Breadth-first_search)
13. [Matrix (225)](https://leetcode.com/tag/matrix/)
    - Wikipedia: [Matrix (mathematics)](https://en.wikipedia.org/wiki/Matrix_(mathematics))
14. [Bit Manipulation (214)](https://leetcode.com/tag/bit-manipulation/)
    - Wikipedia: [Bit manipulation](https://en.wikipedia.org/wiki/Bit_manipulation)
    - Wikipedia: [Bitwise operation](https://en.wikipedia.org/wiki/Bitwise_operation)
15. [Two Pointers (203)](https://leetcode.com/tag/two-pointers/)
16. [Binary Tree (175)](https://leetcode.com/tag/binary-tree/)
    - Wikipedia: [Binary tree](https://en.wikipedia.org/wiki/Binary_tree)
17. [Heap (Priority Queue) (169)](https://leetcode.com/tag/heap-priority-queue/)
    - Wikipedia: [Priority queue](https://en.wikipedia.org/wiki/Priority_queue)
    - Wikipedia: [Heap (data structure)](https://en.wikipedia.org/wiki/Heap_(data_structure))
18. [Prefix Sum (163)](https://leetcode.com/tag/prefix-sum/)
    - Wikipedia: [Prefix sum](https://en.wikipedia.org/wiki/Prefix_sum)
19. [Stack (155)](https://leetcode.com/tag/stack/)
    - Wikipedia: [Stack (abstract data type)](https://en.wikipedia.org/wiki/Stack_(abstract_data_type))
20. [Simulation (153)](https://leetcode.com/tag/simulation/)
21. [Graph (142)](https://leetcode.com/tag/graph/)
    - Wikipedia: [Graph (abstract data type)](https://en.wikipedia.org/wiki/Graph_(abstract_data_type))
22. [Counting (133)](https://leetcode.com/tag/counting/)
23. [Design (123)](https://leetcode.com/tag/design/)
24. [Sliding Window (119)](https://leetcode.com/tag/sliding-window/)
25. [Backtracking (102)](https://leetcode.com/tag/backtracking/)
    - Wikipedia: [Backtracking](https://en.wikipedia.org/wiki/Backtracking)
26. [Enumeration (86)](https://leetcode.com/tag/enumeration/)
27. [Union Find (82)](https://leetcode.com/tag/union-find/)
    - Wikipedia: [Disjoint-set data structure](https://en.wikipedia.org/wiki/Disjoint-set_data_structure)
28. [Linked List (75)](https://leetcode.com/tag/linked-list/)
    - Wikipedia: [Linked list](https://en.wikipedia.org/wiki/Linked_list)
29. [Ordered Set (61)](https://leetcode.com/tag/ordered-set/)
    - Wikipedia: [Set (abstract data type)](https://en.wikipedia.org/wiki/Set_(abstract_data_type))
30. [Monotonic Stack (58)](https://leetcode.com/tag/monotonic-stack/)

    A monotonic stack is a stack data structure that maintains its elements in either an increasing or decreasing order. Here are its key properties:

    1. Order Maintenance:
        - In a **Monotonic Increasing Stack**, each new element pushed onto the stack is greater than or equal to the element at the top of the stack.
        - In a **Monotonic Decreasing Stack**, each new element pushed onto the stack is less than or equal to the element at the top of the stack.
    2. Efficiency:
        - It allows for efficient retrieval of the next greater or next smaller element in a sequence, typically in linear time `O(n)`.
    3. Dynamic Updates:
        - As elements are added or removed, the stack dynamically maintains its monotonic property, ensuring that the operations of pushing and popping elements are efficient.
    4. Application:
        - Monotonic stacks are commonly used in problems involving the next greater element, next smaller element, stock span problems, and histogram problems.

31. [Number Theory (55)](https://leetcode.com/tag/number-theory/)
    - Wikipedia: [Number theory](https://en.wikipedia.org/wiki/Number_theory)
32. [Trie (53)](https://leetcode.com/tag/trie/)
    - Wikipedia: [Trie](https://en.wikipedia.org/wiki/Trie)
    - Wikipedia: [Radix tree](https://en.wikipedia.org/wiki/Radix_tree)
    - Wikipedia: [Suffix tree](https://en.wikipedia.org/wiki/Suffix_tree)
33. [Divide and Conquer (47)](https://leetcode.com/tag/divide-and-conquer/)
    - Wikipedia: [Divide-and-conquer algorithm](https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm)
34. [Segment Tree (46)](https://leetcode.com/tag/segment-tree/)
    - Wikipedia: [Segment tree](https://en.wikipedia.org/wiki/Segment_tree)
35. [Bitmask (45)](https://leetcode.com/tag/bitmask/)
    - Wikipedia: [Mask (computing)](https://en.wikipedia.org/wiki/Mask_(computing))
36. [Queue (45)](https://leetcode.com/tag/queue/)
    - Wikipedia: [Queue (abstract data type)](https://en.wikipedia.org/wiki/Queue_(abstract_data_type))
37. [Recursion (45)](https://leetcode.com/tag/recursion/)
    - Wikipedia: [Recursion (computer science)](https://en.wikipedia.org/wiki/Recursion_(computer_science))
38. [Binary Search Tree (40)](https://leetcode.com/tag/binary-search-tree/)
    - Wikipedia: [Binary search tree](https://en.wikipedia.org/wiki/Binary_search_tree)
39. [Memoization (38)](https://leetcode.com/tag/memoization/)
    - Wikipedia: [Memoization](https://en.wikipedia.org/wiki/Memoization)
40. [Binary Indexed Tree (38)](https://leetcode.com/tag/binary-indexed-tree/)
    - Wikipedia: [Fenwick tree](https://en.wikipedia.org/wiki/Fenwick_tree)
41. [Geometry (37)](https://leetcode.com/tag/geometry/)
    - Wikipedia: [Geometry](https://en.wikipedia.org/wiki/Geometry)
42. [Hash Function (36)](https://leetcode.com/tag/hash-function/)
    - Wikipedia: [Hash function](https://en.wikipedia.org/wiki/Hash_function)
43. [Combinatorics (33)](https://leetcode.com/tag/combinatorics/)
    - Wikipedia: [Combinatorics](https://en.wikipedia.org/wiki/Combinatorics)
44. [Topological Sort (32)](https://leetcode.com/tag/topological-sort/)
    - Wikipedia: [Topological sorting](https://en.wikipedia.org/wiki/Topological_sorting)
45. [String Matching (30)](https://leetcode.com/tag/string-matching/)
46. [Shortest Path (28)](https://leetcode.com/tag/shortest-path/)
    - Wikipedia: [Shortest path problem](https://en.wikipedia.org/wiki/Shortest_path_problem)
47. [Rolling Hash (28)](https://leetcode.com/tag/rolling-hash/)
48. [Game Theory (25)](https://leetcode.com/tag/game-theory/)
    - Wikipedia: [Game theory](https://en.wikipedia.org/wiki/Game_theory)
49. [Interactive (23)](https://leetcode.com/tag/interactive/)
50. [Data Stream (20)](https://leetcode.com/tag/data-stream/)
51. [Brainteaser (16)](https://leetcode.com/tag/brainteaser/)
52. [Monotonic Queue (15)](https://leetcode.com/tag/monotonic-queue/)

    A monotonic queue is a data structure that is used to maintain the elements in a specific order (either increasing or decreasing) to quickly find the minimum or maximum within a sliding window. The key property of a monotonic queue is that its elements are ordered in a way that facilitates constant-time retrieval of the minimum or maximum value.

    ## Key Features:
    1. **Monotonic Increasing Queue**: Elements in the queue are arranged such that each successive element is greater than or equal to the previous one. This facilitates quick access to the maximum value within the current sliding window.
    2. **Monotonic Decreasing Queue**: Elements in the queue are arranged such that each successive element is less than or equal to the previous one. This structure enables efficient retrieval of the minimum value within the current sliding window.

    ## Usage:
    - Monotonic queues are particularly useful for problems where you need to find extreme values (maximum or minimum) over every possible contiguous subarray (sliding window) of a given size in an array.

    ## Implementation:
    - Data Structure: Implemented typically using a deque (double-ended queue) in programming languages like C++ or Python, allowing efficient insertion and deletion operations from both ends.
    - Algorithm:
        1. Iterate through the array while maintaining the monotonic property of the queue.
        2. Adjust the queue to ensure it reflects the monotonic nature as new elements are added or as the sliding window moves.
        3. Retrieve extreme values (maximum or minimum) from the queue as the sliding window moves across the array.

    Monotonic queues offer a time-efficient solution (often O(n) complexity) to sliding window problems where maintaining the order of elements is crucial for quick retrieval of extreme values within each window.

53. [Randomized (12)](https://leetcode.com/tag/randomized/)
54. [Merge Sort (12)](https://leetcode.com/tag/merge-sort/)
    - Wikipedia: [Merge sort](https://en.wikipedia.org/wiki/Merge_sort)
55. [Iterator (9)](https://leetcode.com/tag/iterator/)
    - Wikipedia: [Iterator](https://en.wikipedia.org/wiki/Iterator)
56. [Concurrency (9)](https://leetcode.com/tag/concurrency/)
57. [Doubly-Linked List (8)](https://leetcode.com/tag/doubly-linked-list/)
    - Wikipedia: [Doubly linked list](https://en.wikipedia.org/wiki/Doubly_linked_list)
58. [Probability and Statistics (7)](https://leetcode.com/tag/probability-and-statistics/)
    - Wikipedia: [Probability theory](https://en.wikipedia.org/wiki/Probability_theory)
    - Wikipedia: [Probability](https://en.wikipedia.org/wiki/Probability)
    - Wikipedia: [Statistics](https://en.wikipedia.org/wiki/Statistics)
59. [Quickselect (7)](https://leetcode.com/tag/quickselect/)
    - Wikipedia: [Quickselect](https://en.wikipedia.org/wiki/Quickselect)
60. [Counting Sort (6)](https://leetcode.com/tag/counting-sort/)
    - Wikipedia: [Counting sort](https://en.wikipedia.org/wiki/Counting_sort)
61. [Bucket Sort (6)](https://leetcode.com/tag/bucket-sort/)
    - Wikipedia: [Bucket sort](https://en.wikipedia.org/wiki/Bucket_sort)
62. [Suffix Array (6)](https://leetcode.com/tag/suffix-array/)
    - Wikipedia: [Suffix array](https://en.wikipedia.org/wiki/Suffix_array)
    - Wikipedia: [Suffix tree](https://en.wikipedia.org/wiki/Suffix_tree)
63. [Minimum Spanning Tree (5)](https://leetcode.com/tag/minimum-spanning-tree/)
    - Wikipedia: [Minimum spanning tree](https://en.wikipedia.org/wiki/Minimum_spanning_tree)
64. [Shell (4)](https://leetcode.com/tag/shell/)
65. [Line Sweep (4)](https://leetcode.com/tag/line-sweep/)
66. [Reservoir Sampling (4)](https://leetcode.com/tag/reservoir-sampling/)
67. [Strongly Connected Component (3)](https://leetcode.com/tag/strongly-connected-component/)
68. [Eulerian Circuit (3)](https://leetcode.com/tag/eulerian-circuit/)
69. [Radix Sort (3)](https://leetcode.com/tag/radix-sort/)
    - Wikipedia: [Radix sort](https://en.wikipedia.org/wiki/Radix_sort)
70. [Rejection Sampling (2)](https://leetcode.com/tag/rejection-sampling/)
71. [Biconnected Component (1)](https://leetcode.com/tag/biconnected-component/)
---

- Date: 2024.07.15
- Code:
    ```javascript
    // 1. open 'https://leetcode.com/problemset/' in Google Chome;
    // 2. **Inspect** any tag name, and select the container `div` node in `Elements`
    //    tab, and select 'Copy JS Path' command in context menu;
    // 3. assign pasteboard contents to variable `targetNode`, and run the follow code.
    const container = document.querySelector("<chrome-generated>");
    const lines = [];
    for (let i = 0; i < container.children.length; ++i) {
      const a = container.children.item(i).children.item(0);
      const link = a.href.replace(/\/?$/, '/');
      const name = a.children.item(0).innerText;
      const total = a.children.item(1).innerText;
      lines.push(`${i + 1}. [${name} (${total})](${link})`);
    }
    const contents = lines.join('\n');
    console.log(contents);
    ```
